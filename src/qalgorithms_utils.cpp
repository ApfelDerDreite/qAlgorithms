// qalgorithms_utils.cpp
#include "../include/qalgorithms_utils.h"

namespace q {

  int sum(const std::vector<int>& vec) {
    double sum = 0.0;
    for (const auto& elem : vec) {
        sum += elem;}
    return sum;}

  size_t sum(const std::vector<size_t>& vec) {
    double sum = 0.0;
    for (const auto& elem : vec) {
        sum += elem;}
    return sum;}

  double sum(const std::vector<double>& vec) {
    double sum = 0.0;
    for (const auto& elem : vec) {
        sum += elem;}
    return sum;}

  int sum(const bool* vec, size_t n) {
    int sum = 0;
    for (size_t i = 0; i < n; i++) {
      sum += vec[i];}
    return sum;}

  template <typename T>
  std::vector<bool> operator<(const std::vector<T>& vec, T scalar) {
    std::vector<bool> result(vec.size());
    int u = 0;
    for (const auto& elem : vec) {
        result[u] = elem < scalar;
        u++;
    }
    return result;
  }

  template <typename T>
  std::vector<bool> operator>(
    const std::vector<T>& vec, 
    T scalar) {
      std::vector<bool> result(vec.size());
      int u = 0;
      for (const auto& elem : vec) {
          result[u] = elem > scalar;
          u++;
      }
      return result;
  }

  template <typename T>
  std::vector<T> operator*(
    const std::vector<T>& A, 
    const std::vector<T>& B) {
      std::vector<T> product(A.size());
      for (size_t i = 0; i < A.size(); i++){
        product[i] = A[i] * B[i];
      }
      return product;
  }

  std::vector<bool> operator&&(
    const std::vector<bool>& A, 
    const std::vector<bool>& B) {
      std::vector<bool> result(A.size());
      for (size_t i = 0; i < A.size(); i++) {
        result[i] = A[i] & B[i];
      }
      return result;
  }

  std::vector<bool> operator!(const std::vector<bool>& A) {
    std::vector<bool> result(A.size());
    for (size_t i = 0; i < A.size(); i++) {
      result[i] = !A[i];
    }
    return result;
  }

  void operator|=(
    std::vector<bool>& A, 
    const std::vector<bool>& B) {
      for (size_t i = 0; i < A.size(); i++) {
        bool tempA = A[i];
        bool tempB = B[i];
        tempA |= tempB;
        A[i] = tempA;
      }
  }

  double erfi(const double x) {
    /* This function uses the Dawson Integral, i.e. 
    erfi(x) = 2 * Dawson * exp(x^2) / sqrt(pi) 
    
    The Dawson Integral is calculated by Stan Sykora's rational function approximations. URL : http://www.ebyte.it/library/codesnippets/DawsonIntegralApproximations.html (Dawson5())
    */
   // calculate the Dawson Integral:
   double y,p,q;
    y = x*x;
    p = 1.0 + y*(0.1049934947 + y*(0.0424060604
            + y*(0.0072644182 + y*(0.0005064034
            + y*(0.0001789971)))));
    q = 1.0 + y*(0.7715471019 + y*(0.2909738639
            + y*(0.0694555761 + y*(0.0140005442
            + y*(0.0008327945 + 2*0.0001789971*y)))));
    double D =  x*(p/q);

    return D * std::exp(x*x) / SQRTPI_2; // @todo: define M_2_SQRTPI in utils
  }

  double tValuesArray[500] = {6.313751515, 2.91998558, 2.353363435, 2.131846781, 2.015048373, 1.94318028, 1.894578605, 1.859548038, 1.833112933, 1.812461123, 1.795884819, 1.782287556, 1.770933396, 1.761310136, 1.753050356, 1.745883676, 1.739606726, 1.734063607, 1.729132812, 1.724718243, 1.720742903, 1.717144374, 1.713871528, 1.71088208, 1.708140761, 1.70561792, 1.703288446, 1.701130934, 1.699127027, 1.697260894, 1.695518789, 1.693888742, 1.692360304, 1.690924251, 1.689572454, 1.688297711, 1.687093617, 1.685954458, 1.684875119, 1.683851011, 1.682878, 1.681952356, 1.681070702, 1.680229975, 1.679427392, 1.678660413, 1.677926721, 1.677224195, 1.676550892, 1.675905025, 1.67528495, 1.674689153, 1.674116236, 1.673564906, 1.673033965, 1.672522303, 1.672028888, 1.671552762, 1.671093032, 1.670648865, 1.670219484, 1.669804162, 1.669402222, 1.669013025, 1.668635976, 1.668270514, 1.667916114, 1.667572281, 1.667238549, 1.666914479, 1.666599658, 1.666293696, 1.665996224, 1.665706893, 1.665425373, 1.665151353, 1.664884537, 1.664624644, 1.664371409, 1.664124579, 1.663883913, 1.663649184, 1.663420175, 1.663196679, 1.6629785, 1.662765449, 1.662557349, 1.662354029, 1.662155326, 1.661961084, 1.661771155, 1.661585397, 1.661403674, 1.661225855, 1.661051817, 1.66088144, 1.66071461, 1.660551217, 1.660391156, 1.660234326, 1.66008063, 1.659929976, 1.659782273, 1.659637437, 1.659495383, 1.659356034, 1.659219312, 1.659085144, 1.658953458, 1.658824187, 1.658697265, 1.658572629, 1.658450216, 1.658329969, 1.65821183, 1.658095744, 1.657981659, 1.657869522, 1.657759285, 1.657650899, 1.657544319, 1.657439499, 1.657336397, 1.65723497, 1.657135178, 1.657036982, 1.656940344, 1.656845226, 1.656751594, 1.656659413, 1.656568649, 1.65647927, 1.656391244, 1.656304542, 1.656219133, 1.656134988, 1.65605208, 1.655970382, 1.655889868, 1.655810511, 1.655732287, 1.655655173, 1.655579143, 1.655504177, 1.655430251, 1.655357345, 1.655285437, 1.655214506, 1.655144534, 1.6550755, 1.655007387, 1.654940175, 1.654873847, 1.654808385, 1.654743774, 1.654679996, 1.654617035, 1.654554875, 1.654493503, 1.654432901, 1.654373057, 1.654313957, 1.654255585, 1.654197929, 1.654140976, 1.654084713, 1.654029128, 1.653974208, 1.653919942, 1.653866317, 1.653813324, 1.653760949, 1.653709184, 1.653658017, 1.653607437, 1.653557435, 1.653508002, 1.653459126, 1.6534108, 1.653363013, 1.653315758, 1.653269024, 1.653222803, 1.653177088, 1.653131869, 1.653087138, 1.653042889, 1.652999113, 1.652955802, 1.652912949, 1.652870547, 1.652828589, 1.652787068, 1.652745977, 1.65270531, 1.652665059, 1.652625219, 1.652585784, 1.652546746, 1.652508101, 1.652469842, 1.652431964, 1.65239446, 1.652357326, 1.652320556, 1.652284144, 1.652248086, 1.652212376, 1.652177009, 1.652141981, 1.652107286, 1.65207292, 1.652038878, 1.652005156, 1.651971748, 1.651938651, 1.651905861, 1.651873373, 1.651841182, 1.651809286, 1.651777679, 1.651746359, 1.65171532, 1.65168456, 1.651654074, 1.651623859, 1.651593912, 1.651564228, 1.651534805, 1.651505638, 1.651476725, 1.651448062, 1.651419647, 1.651391475, 1.651363544, 1.65133585, 1.651308391, 1.651281164, 1.651254165, 1.651227393, 1.651200843, 1.651174514, 1.651148402, 1.651122505, 1.65109682, 1.651071345, 1.651046077, 1.651021013, 1.650996152, 1.65097149, 1.650947025, 1.650922755, 1.650898678, 1.650874791, 1.650851092, 1.650827579, 1.65080425, 1.650781102, 1.650758134, 1.650735342, 1.650712727, 1.650690284, 1.650668012, 1.65064591, 1.650623976, 1.650602207, 1.650580601, 1.650559157, 1.650537873, 1.650516748, 1.650495779, 1.650474964, 1.650454303, 1.650433793, 1.650413433, 1.65039322, 1.650373154, 1.650353233, 1.650333455, 1.650313819, 1.650294323, 1.650274966, 1.650255746, 1.650236662, 1.650217713, 1.650198896, 1.650180211, 1.650161656, 1.650143229, 1.650124931, 1.650106758, 1.650088711, 1.650070786, 1.650052985, 1.650035304, 1.650017743, 1.650000301, 1.649982976, 1.649965767, 1.649948674, 1.649931694, 1.649914828, 1.649898073, 1.649881428, 1.649864893, 1.649848466, 1.649832147, 1.649815934, 1.649799826, 1.649783823, 1.649767922, 1.649752124, 1.649736428, 1.649720831, 1.649705334, 1.649689935, 1.649674634, 1.649659429, 1.649644319, 1.649629305, 1.649614384, 1.649599556, 1.64958482, 1.649570176, 1.649555622, 1.649541157, 1.649526781, 1.649512493, 1.649498293, 1.649484178, 1.649470149, 1.649456205, 1.649442344, 1.649428567, 1.649414873, 1.64940126, 1.649387728, 1.649374276, 1.649360905, 1.649347611, 1.649334397, 1.649321259, 1.649308199, 1.649295214, 1.649282305, 1.649269471, 1.649256711, 1.649244024, 1.649231411, 1.64921887, 1.6492064, 1.649194001, 1.649181673, 1.649169415, 1.649157226, 1.649145105, 1.649133053, 1.649121068, 1.64910915, 1.649097298, 1.649085513, 1.649073792, 1.649062137, 1.649050545, 1.649039017, 1.649027553, 1.649016151, 1.649004811, 1.648993533, 1.648982315, 1.648971159, 1.648960062, 1.648949026, 1.648938048, 1.648927129, 1.648916269, 1.648905466, 1.64889472, 1.648884031, 1.648873399, 1.648862822, 1.648852302, 1.648841836, 1.648831425, 1.648821068, 1.648810764, 1.648800515, 1.648790318, 1.648780173, 1.648770081, 1.648760041, 1.648750052, 1.648740114, 1.648730226, 1.648720389, 1.648710601, 1.648700863, 1.648691174, 1.648681534, 1.648671941, 1.648662397, 1.648652901, 1.648643451, 1.648634049, 1.648624693, 1.648615383, 1.64860612, 1.648596901, 1.648587728, 1.6485786, 1.648569516, 1.648560477, 1.648551481, 1.648542529, 1.64853362, 1.648524754, 1.64851593, 1.648507149, 1.64849841, 1.648489713, 1.648481057, 1.648472442, 1.648463868, 1.648455335, 1.648446842, 1.648438388, 1.648429975, 1.648421601, 1.648413266, 1.648404969, 1.648396712, 1.648388493, 1.648380311, 1.648372168, 1.648364062, 1.648355993, 1.648347961, 1.648339967, 1.648332008, 1.648324086, 1.6483162, 1.648308349, 1.648300534, 1.648292755, 1.64828501, 1.648277301, 1.648269625, 1.648261984, 1.648254378, 1.648246805, 1.648239266, 1.64823176, 1.648224287, 1.648216847, 1.648209441, 1.648202066, 1.648194724, 1.648187415, 1.648180137, 1.64817289, 1.648165676, 1.648158492, 1.64815134, 1.648144219, 1.648137128, 1.648130068, 1.648123038, 1.648116038, 1.648109068, 1.648102128, 1.648095217, 1.648088336, 1.648081483, 1.64807466, 1.648067866, 1.6480611, 1.648054362, 1.648047653, 1.648040972, 1.648034319, 1.648027693, 1.648021096, 1.648014525, 1.648007982, 1.648001465, 1.647994976, 1.647988513, 1.647982077, 1.647975667, 1.647969283, 1.647962926, 1.647956594, 1.647950288, 1.647944008, 1.647937753, 1.647931523, 1.647925318, 1.647919139, 1.647912984, 1.647906854};
  const double SQRTPI_2 = std::sqrt(M_PI) / 2;

  const double& tValues::operator[](size_t degreeOfFreedom) const {
    return values.at(degreeOfFreedom);
  }

  const Matrix linreg(
    const std::vector<double>& xData, 
    const std::vector<double>& yData,
    const int degree) {
      // Create the matrix X
      Matrix X(xData.size(), degree + 1);
      for (size_t i = 0; i < xData.size(); i++) {
        for (size_t j = 0; j < degree + 1; j++) {
          X(i, j) = std::pow(xData[i], j);
        }
      }
      // Create the matrix Y
      Matrix Y(yData.size(), 1);
      for (size_t i = 0; i < yData.size(); i++) {
        Y(i, 0) = yData[i];
      }
      // Calculate the coefficients
      Matrix X_T = X.T();
      Matrix X_T_X = X_T * X;
      Matrix X_T_X_inv = X_T_X.inv();
      Matrix X_T_Y = X_T * Y;
      Matrix coefficients = X_T_X_inv * X_T_Y;
      return coefficients;
  }

  ProgressBar::ProgressBar(int total, int width)
    : total(total), width(width), colors({
        "\033[1;31m", // red
        "\033[1;31m", // red
        "\033[1;31m", // red
        "\033[1;33m", // yellow
        "\033[1;33m", // yellow
        "\033[1;33m", // yellow
        "\033[1;32m", // green
        "\033[1;32m", // green
        "\033[1;32m", // green
        "\033[1;36m", // cyan
        "\033[1;36m", // cyan
        "\033[1;36m", // cyan
        "\033[1;34m", // blue
        "\033[1;34m", // blue
        "\033[1;34m", // blue
        "\033[1;35m"  // magenta
        "\033[1;35m"  // magenta
        "\033[1;35m"  // magenta
    }) {}

  void ProgressBar::update(int current) {
      int percentage = static_cast<int>(100.0 * current / total);
      int pos = width * current / total;

      std::string bar;
      for (int i = 0; i < width; ++i) {
          std::string color = colors[i % colors.size()];
          if (i < pos) bar += color + "#";
          else if (i == pos) bar += color + ">";
          else bar += "\033[0m ";
      }

      // std::cout << "\r[" << bar << "\033[0m] " << percentage << "%";
      std::cout << "\r[" << bar << "\033[0m] " << percentage << "%";
      std::cout.flush();
  }

  void ProgressBar::complete() {
      std::cout << "\033[1;32m" <<  " .... done." << "\033[0m" << std::endl;
  }
}