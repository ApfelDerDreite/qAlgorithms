Erste Zeile der csv-Datei wird ignoriert. csv muss mit den Spaltennamen o.Ä. anfangen
Parallelisieren: Ein thread je subset-Operation; wahrscheinlich nicht signifikant schneller

Gibt es einen Zusammenhang zwischen Zentroidfehler und der Eigenschaft, nicht in einem Bin zu landen / Anfang Bzw. Ende eines Bins zu sein?
Config-Datei

https://www.agner.org/optimize/optimizing_cpp.pdf

prüfen, wie das Programm skaliert -> subdatensätze

ctime:
int now = time(0)

time(o) - now

gcc -Wall -Werror .\src\qalgorithms_qbin.cpp  

Methode: I/O, minimalbeispiel (Reihenfolge, ~10E array), paper verlinken (Seitenzahl),

Gerrit soll code aufräumen -> Namen, Funktionen trennen, Kommentare selber schreiben, redundanten Müll entfernen, echte pointer statt &, eckige Klammern für operator overload (matrixcode durch besse Bibliothek ersetzen, da jede Operation die gesamte Matrix kopiert @todo kontrollieren), wenn es getter und setter gibt sollte die variable public sein

https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0125108

Kein Zshg zwischen DQS-differenz und mz, scans

Entwicklung des DQS mit maxdist

https://link.springer.com/article/10.1007/s41060-021-00275-z#Sec2

Gradheit eines bins als Qualitätskriterium?

Schlechtmöglichste MID, schlechteste MOD => Schlechtmöglichster DQS in Abhängigkeit von n

Bestimme durchschnittliche MID für die Verteilung mit n Mitliedern, die grade eben noch
normalverteilt ist 

Der schlechteste mögliche DQS sinkt mit n, Beweis?

Wichtig: Binning ist nur ein Schritt, und sollte entsprechend auf gute Endergebnisse
hin optimiert werden

Mögliche Optimierung: Reduziere Datapoint auf mz, rt, pointer für bessere Cachenutzung

Vorgehen DQS: Arbeite mit empirischer Stabw * 1.128 für MID, MOD = maxdist(n) => genauere Bestimmung des Faktors, test auf Abhängigkeit von n

quantile function ist inverse der normalverteilung

gibt es ein MID > vcrit im Datensatz?

großen Multistandard-Datensatz anfragen

long doubles wieder entfernen

Korrelationen mit Anzahl fehlender scans?

Falsche DQS: Bin wurde von einem viel größeren abgetrennt, der critVal entsprechend reduziert hat.
    zeigen kein besonders auffälliges Verhalten Bzgl. subsetting-Schritt

Instead of returning a composite object, you may consider the following alternatives:
• Make the function a constructor for the object.
• Make the function modify an existing object rather than making a new one. The
existing object can be made available to the function through a pointer or reference,
or the function could be a member of the object's class.
• Make the function return a pointer or reference to a static object defined inside the
function. This is efficient, but risky. The returned pointer or reference is valid only
until the next time the function is called and the local object is overwritten, possibly in
a different thread. If you forget to make the local object static then it becomes invalid
as soon as the function returns.
