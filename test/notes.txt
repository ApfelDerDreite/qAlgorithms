1) m/z, RT etc. werden als vector<double> ausgegeben - Ausgabe sollte mehrere Schreibweisen, z.B. mz, m/z, RT, rt und andere gängige Versionen akzeptieren
2) Erste Zeile der csv-Datei wird separat in RawData eingelesen. csv muss mit den Spaltennamen anfangen
3) Input: Vektor von Vektoren, 1. Zeile enthält Namen
test.csv: muss mz als 1., RT als 2. spalte haben; es müssen für alle Spalten Werte vorliegen - setze auf nonsense-Wert, um Fehlzuweisungen zu vermeiden?
Parallelisieren: Im 1. Schritt des Binnings wird der Datensatz an allen Stellen mit nos > critval(5) gespalten und auf einen neuen thread gegeben

Gibt es einen Zusammenhang zwischen Zentroidfehler und der Eigenschaft, nicht in einem Bin zu landen / Anfang Bzw. Ende eines Bins zu sein?
Config-Datei

Füge den RawData vektor an den Bincontainer an

Alles umorganisieren, um in einem Struct alle Eigenschaften eines Features zu speichern?
https://stackoverflow.com/questions/5174115/sorting-a-vector-of-objects-by-a-property-of-the-object

Wenn der Bin nach Teilen in RT/Scans genau so groß ist wie vorher, muss nicht erneut mit mz kontorolliert werden

Duplizierte Features crashen den code
https://www.agner.org/optimize/optimizing_cpp.pdf

pointer -> methode


massefehler für mehrere Featurelisten?

qGrouping

ßßß Intensitätsprofile

Kriterium für besseres DQS-berechnen (Subsampling?) // erst nur im selben scan suchen und anschließend die mit gutem DQS priorisieren
mittlere innendistanz optimieren
 
 Sortiere Featureliste nur im Bereich von scans, dann suche jeweils nächstes mz 

überspringe n Werte pro suchvorgang
1. Relativ viele Suchvorgänge in einem Scan brauchen 0-1 Iterationen


#include <cmath>
#include <cstdlib>
#include <ctime>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

long sum(int *array, long length) {
  long sum = 0;
  for (long i = 0; i < length; i++) {
    sum += array[i];
  }
  return sum;
}

int cmp(const void *a, const void *b) { return *(int *)a > *(int *)b; }

int main() {
    long length = 200000000;
    int *v1 = (int *)malloc(sizeof(int) * length);
    srand(0);
    std::cout << "test";
    for (long i = 0; i < length; i++) {
      v1[i] = rand();
    }

    qsort(v1, length, sizeof(int), cmp);
    volatile long *results = (long *)malloc(sizeof(long) * length);
    time_t start = time(0);
    long beforeSum = sum(v1, length);
    long afterSum = 0;
    for (long i = 0; i < length; i++) {
      long val = (beforeSum - v1[i] * (length - i));
      long val2 = (v1[i] * i - afterSum);
      results[i] = val + val2 /n-1;
      beforeSum -= v1[i];
      afterSum += v1[i];
    }
    time_t end = time(0);
//    for (int i = 0; i < length; i++) {
//      printf("|%d|\n", v1[i]);
//    }
//    for (int i = 0; i < length; i++) {
//      printf("|%ld|\n", results[i]);
//    }
//    printf("done in: %ld", end - start);
}

doubles -> floats

prüfen, wie das Programm skaliert -> subdatensätze
reduce nutzen?